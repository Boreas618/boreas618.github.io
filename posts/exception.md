# AArch64 Exception and Interrupt Handling

**Exception**s in AArch64 can be categorized into two types: **asynchronous** and **synchronous**. Certain types of asynchronous exceptions are referred to as **interrupt**s.

Causes of exceptions:

* **Aborts**: failed instruction fetches (Instruction Aborts), failed data accesses (Data Aborts), MMU aborts. In AArch64, synchronous aborts cause a Synchronous exception. Asynchronous aborts cause an SError interrupt exception.
* **Reset**: used to execute code on the core to initialize it, after the system has powered up. The address of its vector can be read from the Reset Vector Base Address Register **RVBAR_ELn**, where n is the number of the highest implemented Exception level.
* **Exception Generating Instructions**: Supervisor Call (SVC),  Hypervisor Call (HVC), Secure monitor Call (SMC).
* **Interrupts**: IRQ, FIQ and SError. FIQ is higher priority than IRQ. Both of these interrupts are typically associated with individual input pins for each core. The corresponding exception type is raised when the current instruction finishes executing. On almost all systems, various interrupt sources are connected using an interrupt controller. The interrupt controller arbitrates and prioritizes interrupts, and in turn, provides a serialized single signal that is then connected to the FIQ or IRQ signal of the core.

## Synchronous and Asynchronous Exceptions

**Synchronous Exceptions**: generated by direct execution of instructions and the return address indicates the instruction which caused it.

**Asynchronous Exceptions**: IRQ, FIQ, or SError (System Error). System errors have several possible causes, the most common being asynchronous Data Aborts (for example, an abort that is triggered by write-back of dirty data from a cache line to external memory).

### Handling Synchronous Exceptions

The Exception Syndrome Register (**ESR_ELn**): the reasons for the exception.

The Fault Address Register (**FAR_ELn**): the faulting virtual address for all synchronous instruction and Data Aborts and alignment faults.

The Exception Link Register (**ELR_ELn**) also holds the address of the instruction that caused the aborting data access (for Data Aborts). These are updated after a memory fault, but are set in other circumstances, for example, by branching to a misaligned address.

The **SCR_EL3** register specifies which exceptions are routed to EL3 and similarly, **HCR_EL2** specifies which exceptions are routed to EL2.

### The Exception Syndrome Register

Updated only for synchronous exceptions and SError. It is not updated for IRQ or FIQ as these interrupt handlers typically obtain status information from registers in the Generic Interrupt Controller (GIC).

<img src="https://p.ipic.vip/yug70w.png" alt="Screenshot 2024-02-24 at 4.41.53 PM" style="zoom:50%;" />

* **Bits [31:26]** (ESR_ELn.EC) indicate the exception class which enables the handler to distinguish between the various possible exception causes (such as unallocated instruction, exceptions from MCR or MRC to CP15, exception from FP operation, SVC, HVC or SMC executed, Data Aborts, and alignment exceptions). For example, EC = 101111 is an SError interrupt.

* **Bit [25]** (ESR_ELn.IL) indicates the length of the trapped instruction (0 for a 16-bit instruction or 1 for a 32-bit instruction) and is set for certain exception classes.

* **Bits [24:0]** (ESR_ELn.ISS) 

* form the Instruction Specific Syndrome (ISS) field containing

  information specific to that exception type. For example, when a system call instruction (SVC, HVC or SMC) is executed, the field contains the immediate value that is associated with the opcode such as 0x123456 for SVC.

### Unallocated Instructions

* An instruction opcode that is not allocated.
* An instruction that requires a higher level of privilege than the current Exception level.
* An instruction that has been disabled.
* Any instruction when the PSTATE.IL field is set.

### System calls

<img src="https://p.ipic.vip/vg621r.png" alt="Screenshot 2024-02-24 at 5.02.11 PM" style="zoom:50%;" />

## Exception Handling

* When the processor moves from a higher to a lower Exception level, the Execution state can stay the same, or it can switch from AArch64 to AArch32.
* When moving from a lower to a higher Exception level, the Execution state can stay the same or switch from AArch32 to AArch64.

Execution restarts in the Exception level to whicht he Exception is taken, from the exception vector that corresponds to the exception taken. **The exception vector holds the first instruction of the exception handler.**

----

**Work Performed by Hardware on an Exception**:

* Save **PSTATE** in **SPSR_ELn** (where n is the Exception level where the exception is taken)

* **PSTATE** is updated to reflect the new processor status (and this can mean that the Exception level is raised, or it can stay the same).

* The address to return to at the end of the exception is stored in **ELR_ELn**.

* The processor branches to **a vector table** which contains entries for each exception type. The vector table contains a dispatch code, which typically identifies the cause of the exception, and selects and calls the relevant function to handle it.

* When the handler code completes execution it returns to the high-level handler, which then

  executes the **ERET** instruction to return to the application.

* The target Execution State (that is, AArch32 or AArch64) and Exception level for asynchronous exceptions are configured using two system registers, **SCR_EL3** and **HCR_EL2**.

## AArch64 Exception Vector Table

In the ARM architecture, exception vectors are stored in a table, called the exception vector table.

The table contains instructions to be executed, rather than a set of addresses. These would normally be branch instructions that direct the core to the full exception handler. Vectors for individual exceptions are at fixed offsets from the beginning of the table. The virtual address of each table base is set by the Vector Base Address Registers: **VBAR_EL3**, **VBAR_EL2** and **VBAR_EL1**.

The base address is given by VBAR_ELn and each entry has a defined offset from this base address. Each table has 16 entries, with each entry being 128 bytes (32 instructions) in size. The table effectively consists of 4 sets of 4 entries. Which entry is used depends on several factors:

* The type of exception (SError, FIQ, IRQ, or Synchronous)
* If the exception is being taken at the same Exception level, the stack pointer to be used (SP0 or SPn).
* If the exception is being taken at a lower Exception level, the Execution state of the next lower level (AArch64 or AArch32).

<img src="https://grasslab.github.io/osdi/en/_images/lab3_1.jpg" alt="Lab 3 : Exception and Interrupt — nctuos 0.0 documentation" style="zoom: 33%;" />

If kernel code is executing at EL1 and an IRQ interrupt is signaled, an IRQ exception occurs. This particular interrupt is not associated with the hypervisor or secure environment and is also handled within the kernel, and the SPSel bit is set, so **SP_EL1** is used.

## Returning from an Exception

The processor has to be told when to return from an exception by software. This is done in code using the **ERET** instruction. This restores the pre-exception **PSTATE** from **SPSR_ELn** and returns program execution back to the original location by restoring the **PC** from **ELR_ELn**.