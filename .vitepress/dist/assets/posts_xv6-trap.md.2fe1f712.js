import{_ as e,o as s,c as a,Q as t}from"./chunks/framework.5ae544db.js";const m=JSON.parse('{"title":"Exception and Interrupt Handling in xv6","description":"","frontmatter":{},"headers":[],"relativePath":"posts/xv6-trap.md","filePath":"posts/xv6-trap.md"}'),n={name:"posts/xv6-trap.md"},o=t(`<h1 id="exception-and-interrupt-handling-in-xv6" tabindex="-1">Exception and Interrupt Handling in xv6 <a class="header-anchor" href="#exception-and-interrupt-handling-in-xv6" aria-label="Permalink to &quot;Exception and Interrupt Handling in xv6&quot;">​</a></h1><p>In this post, we will introduce how xv6 implement traps.</p><p>In [5], the designers of xv6 share the same understanding of <strong>trap</strong> as the RISC-V specification[4]. In this context, <strong>trap</strong> refers to the transfer of control to a trap handler, which can be triggered by an exception or an interrupt.</p><p>Consider calling the <code>freemem</code> system call to calculate the number of free pages.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">freemem</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#FFAB70;">num</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">fprintf</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;freemem failed!</span><span style="color:#79B8FF;">\\\\\\\\</span><span style="color:#9ECBFF;">n&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">exit</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">freemem</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#E36209;">num</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">fprintf</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;freemem failed!</span><span style="color:#005CC5;">\\\\\\\\</span><span style="color:#032F62;">n&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">exit</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>What happens when the user calls <code>freemem</code>? In other words, to where is the control transferred?</p><p>In fact, the <code>freemem</code> function we call is a &quot;stub&quot; for the system call. Its function body is the following assembly code:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># user/usys.S</span></span>
<span class="line"><span style="color:#e1e4e8;">.global freemem</span></span>
<span class="line"><span style="color:#e1e4e8;">freemem:</span></span>
<span class="line"><span style="color:#e1e4e8;">	li a7, SYS_freemem</span></span>
<span class="line"><span style="color:#e1e4e8;">	ecall</span></span>
<span class="line"><span style="color:#e1e4e8;">	ret</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># user/usys.S</span></span>
<span class="line"><span style="color:#24292e;">.global freemem</span></span>
<span class="line"><span style="color:#24292e;">freemem:</span></span>
<span class="line"><span style="color:#24292e;">	li a7, SYS_freemem</span></span>
<span class="line"><span style="color:#24292e;">	ecall</span></span>
<span class="line"><span style="color:#24292e;">	ret</span></span></code></pre></div><p><code>SYS_freemem</code> is the system call number defined in <code>kernel/syscall.h</code>. In RISC-V, a system call is made by placing the system call number in register <code>a7</code> and executing an <code>ecall</code> instruction to jump to the trap handler.</p><blockquote><p>Before we move on to explore what happens in the trap handler, let&#39;s take a moment to explain why some readers of this post may not be able to find <code>usys.S</code> in <code>user</code>. This is because the file is dynamically generated by the Perl script <code>user/usys.pl</code>. The dynamic generation occurs during the kernel&#39;s make process, which means it can only be seen after running <code>make qemu</code> or other commands that execute the Perl script.</p></blockquote><p>Xv6 trap handling proceeds in four stages: (1) hardware actions taken by the RISC-V CPU, (2) an assembly “vector” that prepares the way for kernel C code, (3) a C trap handler that decides what to do with the trap, and (4) the system call or device-driver service routine [5].</p><h2 id="phase-1-hardware-actions-taken-by-the-risc-v-cpu" tabindex="-1">Phase 1: hardware actions taken by the RISC-V CPU <a class="header-anchor" href="#phase-1-hardware-actions-taken-by-the-risc-v-cpu" aria-label="Permalink to &quot;Phase 1: hardware actions taken by the RISC-V CPU&quot;">​</a></h2><p>We have executed the <code>ecall</code> instruction and the hardware begins to take control, subsequently transferring the control flow to the trap handler. The sequence of hardware actions includes procedures that manipulate registers in order to prepare for the trap handler. Therefore, we will first introduce some registers that will be manipulated in the hardware actions phase and subsequent phases.</p><ul><li><p><code>stvec</code>: The kernel writes the address of its trap handler here; the RISC-V jumps here to handle a trap.</p></li><li><p><code>sepc</code>: When a trap occurs, RISC-V saves the program counter here (since the <code>pc</code> is then overwritten with <code>stvec</code>). The <code>sret</code> (return from trap) instruction copies <code>sepc</code> to the <code>pc</code>. The kernel can write to <code>sepc</code> to control where <code>sret</code> goes.</p></li><li><p><code>scause</code>: The RISC-V puts a number here that describes the reason for the trap.</p></li><li><p><code>sscratch</code>: The kernel places a value here that comes in handy at the very start of a trap handler.</p></li><li><p><code>sstatus</code>: The SIE bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE, the RISC-V will defer device interrupts until the kernel sets SIE. The SPP bit indicates whether a trap came from user mode or supervisor mode, and controls to what mode sret returns.</p></li></ul><p>Here, the leading &#39;s&#39; in the names of the registers means supervisor mode, which is above the user and machine modes.</p><p>When it needs to force a trap, the RISC-V hardware does the following for all trap types (other than timer interrupts):</p><ol><li>If the trap is a device interrupt, and the <code>sstatus</code> SIE bit is clear, don’t do any of the following.</li><li>Disable interrupts by clearing SIE.</li><li>Copy the <code>pc</code> to<code>sepc</code>.</li><li>Save the current mode (user or supervisor) in the SPP bit in <code>sstatus</code>.</li><li>Set <code>scause</code> to reflect the trap’s cause.</li><li>Set the mode to supervisor.</li><li>Copy <code>stvec</code> to the <code>pc</code>.</li></ol><p>The actions performed by hardware are now clear. However, one question remains: when does the kernel write the address of its trap handler into <code>stvec</code>? This is a non-trivial question.</p><p>In the xv6 book [5], traps can be classified into two classes: traps from user space and traps from kernel space. The former include interrupts, exceptions, or system calls from user space, while the latter include interrupts and exceptions from kernel space. It is important to note that exceptions from kernel space are unacceptable and will cause the kernel to panic.</p><p><strong>For traps from user space</strong>, the routine of setting <code>stvec</code> to <code>uservec</code> occurs during the creation of new processes. Specifically, <code>stvec</code> is set to <code>trampoline_uservec</code> in the <code>usertrapret</code> function, which is called in <code>forkret</code>. <code>forkret</code> serves as the entry point for a new process. In summary, <code>stvec</code> is set to the user trap handler when a user process starts to run. <strong>For traps from kernel space</strong>, it is less subtle and clear in the source code.</p><h2 id="phase-2-an-assembly-vector-that-prepares-the-way-for-kernel-c-code" tabindex="-1">Phase 2: an assembly “vector” that prepares the way for kernel C code <a class="header-anchor" href="#phase-2-an-assembly-vector-that-prepares-the-way-for-kernel-c-code" aria-label="Permalink to &quot;Phase 2: an assembly “vector” that prepares the way for kernel C code&quot;">​</a></h2><p>Do you still remember the four phases mentioned above? Now that the actions performed by the hardware are complete, we have jumped to the address specified in <code>stvec</code>. This address is referred to as <strong>an assembly &quot;vector&quot; that prepares the way for kernel C code</strong>.</p><blockquote><p>...</p><p>Xv6 satisfies these constraints with a <em><strong>trampoline</strong></em> page that contains <code>uservec</code>. Xv6 maps the trampoline page at the same virtual address in the kernel page table and in every user page table. This virtual address is <code>TRAMPOLINE</code> (as we saw in Figure 2.3 and in Figure 3.3). The trampoline contents are set in <code>trampoline.S</code>, and (when executing user code) <code>stvec</code> is set to <code>uservec</code> (kernel/trampoline.S:16).</p></blockquote><p>The assembly code for <code>uservec</code> is clear enough with comments. Each process has a virtual memory area called <code>TRAPFRAME</code> where contexts from user space are saved. After the registers have been saved, the kernel stack pointer, page table, and hart id are fetched from <code>TRAPFRAME</code>, and the control is transferred to <code>usertrap</code> now.</p><h2 id="phase-3-a-c-trap-handler-that-decides-what-to-do-with-the-trap" tabindex="-1">Phase 3: a C trap handler that decides what to do with the trap <a class="header-anchor" href="#phase-3-a-c-trap-handler-that-decides-what-to-do-with-the-trap" aria-label="Permalink to &quot;Phase 3: a C trap handler that decides what to do with the trap&quot;">​</a></h2><p>The C trap handler determines the cause of this trap by reading <code>scause</code>. The return address should be set to the next instruction if the trap is a system call. After the trap handler has determined that the trap is a system call, control is transferred to <code>syscall</code>, which will call the predefined system call function according to the system call number specified in <code>a7</code>.</p><h2 id="phase-4-the-system-call-or-device-driver-service-routine" tabindex="-1">Phase 4: the system call or device-driver service routine <a class="header-anchor" href="#phase-4-the-system-call-or-device-driver-service-routine" aria-label="Permalink to &quot;Phase 4: the system call or device-driver service routine&quot;">​</a></h2><p>This is where the system call code is executed. To find the corresponding system call code, the system call number is used to index into a function pointer array and retrieve the appropriate function pointer. The system call functions are defined in <code>sysproc.c</code>.</p><p>Note that if the system call is made by <code>freemem(&amp;num)</code>, which means we have to copy the number of free pages to <code>num</code>, the difference in page tables should be taken into consideration. Because in the kernel, we have a different virtual memory space from the user, which means that we have to consult the virtual memory address of the user process that made the system call to copy the value to the right place.</p><p>This can be done by the following code:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> proc </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myproc</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">uint64 addr;</span></span>
<span class="line"><span style="color:#B392F0;">argaddr</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">&amp;</span><span style="color:#FFAB70;">addr</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;"> // get parameter 0, which is the address of \`num\`</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">copyout</span><span style="color:#E1E4E8;">(p</span><span style="color:#F97583;">-&gt;</span><span style="color:#FFAB70;">pagetable</span><span style="color:#E1E4E8;">, addr, (</span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">&amp;</span><span style="color:#FFAB70;">sum</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(sum)) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> proc </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myproc</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">uint64 addr;</span></span>
<span class="line"><span style="color:#6F42C1;">argaddr</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">&amp;</span><span style="color:#E36209;">addr</span><span style="color:#24292E;">);</span><span style="color:#6A737D;"> // get parameter 0, which is the address of \`num\`</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">copyout</span><span style="color:#24292E;">(p</span><span style="color:#D73A49;">-&gt;</span><span style="color:#E36209;">pagetable</span><span style="color:#24292E;">, addr, (</span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">&amp;</span><span style="color:#E36209;">sum</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(sum)) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><p>Above are the four phases of making and executing system calls in xv6. Handling user space interrupts and exceptions are similar in terms of the four phases. Returning from a trap is all about recovering the user contexts and is similar to saving contexts. The control is transferred from <code>usertrapret</code> to <code>userret</code>, and finally, to the next instructions of the instruction that causes the system call.</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><p><strong>1</strong> OS-23Fall-FDU Repository <a href="https://github.com/idlebo/OS-23Fall-FDU/blob/lab3/doc/trap.explained.md" target="_blank" rel="noreferrer">https://github.com/idlebo/OS-23Fall-FDU/blob/lab3/doc/trap.explained.md</a></p><p><strong>2</strong> Intel® 64 and IA-32 Architectures Software Developer Manuals <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html" target="_blank" rel="noreferrer">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p><p><strong>3</strong> AArch64 Exception and Interrupt Handling <a href="https://developer.arm.com/documentation/100933/0100/AArch64-Exception-and-Interrupt-Handling" target="_blank" rel="noreferrer">https://developer.arm.com/documentation/100933/0100/AArch64-Exception-and-Interrupt-Handling</a></p><p><strong>4</strong> RISC-V Specifications <a href="https://riscv.org/technical/specifications/" target="_blank" rel="noreferrer">https://riscv.org/technical/specifications/</a></p><p><strong>5</strong> Xv6, a simple Unix-like teaching operating system <a href="http://pdos.csail.mit.edu/6.828/2012/xv6.html" target="_blank" rel="noreferrer">http://pdos.csail.mit.edu/6.828/2012/xv6.html</a></p>`,38),r=[o];function l(p,c,i,d,h,y){return s(),a("div",null,r)}const f=e(n,[["render",l]]);export{m as __pageData,f as default};
