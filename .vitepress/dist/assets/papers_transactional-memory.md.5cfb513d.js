import{_ as h,C as y,o as g,c as m,H as l,w as i,Q as p,k as c,n as u}from"./chunks/framework.5ae544db.js";const E="_button_1fkgp_2",f={button:E},b={methods:{open(){fetch("https://lims.fudan.edu.cn/uaa/login?loginType=SJTU&userId=L2064&redirect_uri=http://jwfw.fudan.edu.cn/eams/home.action&state=&authorize_uri=https://uis.fudan.edu.cn/authserver/login&response_type=code&client_id=acme&cas=true",{method:"GET"}).then(s=>{const e=s.headers;console.log(e);const t=e.get("Set-Cookie"),o="https://lims.fudan.edu.cn/api/limsproduct/fdulims/wxAPI/openDoorPython?agentId=1342&username=31543",a=new Headers({Host:"lims.fudan.edu.cn",Authorization:"Bearer "+t.match(/uaa\.access_token=([^;]+)/)[1]});fetch(o,{method:"GET",headers:a})})}}},C=JSON.parse('{"title":"Transactional Memory","description":"","frontmatter":{},"headers":[],"relativePath":"papers/transactional-memory.md","filePath":"papers/transactional-memory.md"}'),w=p(`<h1 id="transactional-memory" tabindex="-1">Transactional Memory <a class="header-anchor" href="#transactional-memory" aria-label="Permalink to &quot;Transactional Memory&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">@article{adl2006unlocking,</span></span>
<span class="line"><span style="color:#e1e4e8;">  title={Unlocking concurrency: Multicore programming with transactional memory},</span></span>
<span class="line"><span style="color:#e1e4e8;">  author={Adl-Tabatabai, Ali-Reza and Kozyrakis, Christos and Saha, Bratin},</span></span>
<span class="line"><span style="color:#e1e4e8;">  journal={Queue},</span></span>
<span class="line"><span style="color:#e1e4e8;">  volume={4},</span></span>
<span class="line"><span style="color:#e1e4e8;">  number={10},</span></span>
<span class="line"><span style="color:#e1e4e8;">  pages={24--33},</span></span>
<span class="line"><span style="color:#e1e4e8;">  year={2006},</span></span>
<span class="line"><span style="color:#e1e4e8;">  publisher={ACM New York, NY, USA}</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">@article{adl2006unlocking,</span></span>
<span class="line"><span style="color:#24292e;">  title={Unlocking concurrency: Multicore programming with transactional memory},</span></span>
<span class="line"><span style="color:#24292e;">  author={Adl-Tabatabai, Ali-Reza and Kozyrakis, Christos and Saha, Bratin},</span></span>
<span class="line"><span style="color:#24292e;">  journal={Queue},</span></span>
<span class="line"><span style="color:#24292e;">  volume={4},</span></span>
<span class="line"><span style="color:#24292e;">  number={10},</span></span>
<span class="line"><span style="color:#24292e;">  pages={24--33},</span></span>
<span class="line"><span style="color:#24292e;">  year={2006},</span></span>
<span class="line"><span style="color:#24292e;">  publisher={ACM New York, NY, USA}</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h2><p><strong>Drawbacks of the current lock-based synchronization</strong>:</p><ul><li><p>Simplistic coarse-grained locking does not scale well.</p></li><li><p>Sophisticated fine-grained locking risks introducing deadlocks and data races.</p></li><li><p>Scalable libraries written using fine-grained locks cannot be easily composed in a way that retains scalability and avoids deadlock and data races.</p><blockquote><p><strong>Example</strong>: assume the programmer wants to perform a composite operation that moves a value from one <strong>concurrent hash map</strong> (using fine-grained locks and supporting concurrent r/w on a single object) to another, while maintaining the invariant that threads always see a key in either one hash map or the other, but never in neither. Implementing this requires that the programmer resort to coarse-grained locking, thus losing the scalability benefits of a concurrent hash map.</p></blockquote></li><li><p>It&#39;s cubersome to handle errors inside the critical section in locking (The errors should be caught and handled properly. Also, the global state should be restored).</p></li></ul>`,5),k=c("img",{src:"https://p.ipic.vip/gus48b.png",alt:"Screenshot 2023-11-29 at 3.38.14 PM",style:{zoom:"25%"}},null,-1),v=p(`<p><strong>Concepts of transactional memory</strong>:</p><ul><li>Commit/Abort</li><li>Isolation: as if other threads are suspended</li></ul><p><strong>Why transactional memory can provide good scalability?</strong></p><ul><li>Allows concurrent read operations to the same variable (Manipulating reader/write lock which has the same function is non-trivial)</li><li>Allows concurrent read and write operations to disjoint, fine-grained data elements (different objects or different array elements)</li></ul><h1 id="theory-mechanisms-and-strategies" tabindex="-1">Theory: Mechanisms and Strategies <a class="header-anchor" href="#theory-mechanisms-and-strategies" aria-label="Permalink to &quot;Theory: Mechanisms and Strategies&quot;">​</a></h1><p><strong>Mechanism: Data Versioning</strong></p><ul><li><p><strong>Eager Versioning</strong>: a write access within a transaction immediately writes to memory the new data version. The old version is buffered in an undo log.</p><blockquote><p><strong>Implementation Details</strong>: to prevent other code from observing the uncommitted new versions (loss of atomicity), eager versioning requires the use of locks or an equivalent hardware mechanism throughout the transaction duration.</p></blockquote></li><li><p><strong>Lazy Versioning</strong>: stores all new data versions in a write buffer until the transaction completes.</p><blockquote><p><strong>Challenges</strong>: delays introduced in transaction commits and the need to search the write buffer first on transaction reads to access the latest data versions.</p></blockquote></li></ul><p><strong>Mechanism: Conflict Dectection</strong></p><p>Tracking read set and write set for each transaction.</p><ul><li><p><strong>Pessimistic Detection</strong>: detect conficts parallelly with reads and writes in transactions. Resolve conficts either by pausing or aborting one transaction. Deadlock is possible.</p></li><li><p><strong>Optimistic Detection</strong>: Assumes conflicts are rare and postpones all checks until the end of each transaction.</p><p><strong>Drawback</strong>: Conflicts are detected late, past the point when a transaction reads or writes the data. Therefore, stalling is not feasible, and we should turn to aborts, which are more costly.</p><p><strong>Benefit</strong>: No deadlock in flight with transaction; more read concurrency as there is no in-flight detection and stalling.</p><p><strong>Not Work with Eager Versioning</strong></p></li></ul><p><strong>Strategy: Granularity of Conflict Detection</strong></p><ul><li><strong>Object-level</strong>: coarse-grained; may cause false conflicts (A and B and writing to different elements of an array).</li><li><strong>Word-level</strong>: eliminates false conflicts; more cost to track and compare read sets and write sets.</li><li><strong>Cache-line-level</strong>: a compromise between the false conflicts (obj-level) and overhead (word-level); Not language-level and hard to program.</li></ul><p><strong>Strategy: Handling Nested Transactions</strong></p><ul><li><strong>Flatten Nested Transactions by Subsuming Any Inner Transactions Within the Outermost</strong>: prohibits explicit transaction aborts</li><li><strong>Support Partial Rollback of the Nested Transactions</strong>: a standalone version management and confict detection for a nested transaction.</li></ul><p><strong>Hybrid strategies</strong>:</p><ul><li>Use <strong>optimistic detection</strong> for reads and <strong>pessimistic detection</strong> for writes.</li><li>Detecting conflicts at the <strong>word level</strong> for arrays and at the <strong>object level</strong> for other data types.</li></ul><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p>Two directions: software and hardware.</p><h3 id="software-transactional-memory" tabindex="-1">Software Transactional Memory <a class="header-anchor" href="#software-transactional-memory" aria-label="Permalink to &quot;Software Transactional Memory&quot;">​</a></h3><p>An STM implementation uses read and write barriers (that is, inserts instrumentation) for all shared memory reads and writes inside transactional code blocks.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  jmpbuf env;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// …</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">setjmp</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">env) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">stmStart</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">stmRead</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">a);</span></span>
<span class="line"><span style="color:#E1E4E8;">      temp1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">stmWrite</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">b, temp1);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">stmCommit</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//…</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">foo</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">arg</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  jmpbuf env;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// …</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">setjmp</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">env) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">stmStart</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">stmRead</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">a);</span></span>
<span class="line"><span style="color:#24292E;">      temp1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">stmWrite</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">b, temp1);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">stmCommit</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//…</span></span></code></pre></div><p>On an abort, the STM library rolls back all the updates performed by the transaction, uses a longjmp to restore the context saved at the beginning of the transaction, and reexecutes the transaction.</p><blockquote><p><strong>Implementation Details</strong></p><ul><li><p>The read and write barriers operate on <strong>transaction records</strong>, pointer-size metadata associated with every piece of data that a transaction may access.</p></li><li><p>The runtime system maintains a <strong>transaction descriptor</strong> for each transaction. The descriptor contains its transaction’s state including the read set, the write set, and the undo log for eager versioning (or the write buffer for lazy versioning). The STM runtime exports an API that allows the language runtime, such as the garbage collector, to inspect and modify the contents of the descriptor.</p></li><li><p>In pessimistic reads, the read barrier acquries a read lock on the corresponding transaction record before reading.</p><p>In optimistic reads, the transaction record holds the verison number for the associated data.</p></li></ul></blockquote><p><strong>Drawbacks</strong>: 40-50 percent overhead &amp; Manage the relationship between transactional and non-transactional code.</p><h3 id="hardware-transactional-memory" tabindex="-1">Hardware Transactional Memory <a class="header-anchor" href="#hardware-transactional-memory" aria-label="Permalink to &quot;Hardware Transactional Memory&quot;">​</a></h3><p>Rely on the <strong>cache hierarchy</strong> and the <strong>cache coherence</strong> protocol to implement versioning and conflict detection.</p><p>Each cache line is annotated with R and W tracking bits that are set on the first read or write to the line</p><ul><li><p><strong>Eager versioning</strong>: Before a cache write, check if this is the first update to the cache line within this transaction (W bit reset). In this case, the cache line and its address are added to the undo log using additional writes to the cache. If the transaction aborts, a hardware or software mechanism must traverse the log and restore the old data versions.</p></li><li><p><strong>Lazy versioning</strong>: A cache line written by the transaction becomes part of the write buffer by setting its W bit. If the transaction aborts, the write buffer is instantaneously flushed by invalidating all cache lines with the W bit set. If the transaction commits, the data in the write buffer becomes instantaneously visible to the rest of the system by resetting the W bits in all cache lines.</p></li><li><p><strong>Pessimistic Detection</strong>: On a read or write access within a transaction, the processor will request shared or exclusive access to the corresponding cache line. A conflict is signaled if a remote cache has a copy of the same line with the R bit set (for an exclusive access request) or the W bit set (for either request type).</p></li><li><p><strong>Optimistic Detection</strong>: During committing, a single, bulk message to other caches.</p></li></ul><p><strong>Drawbacks</strong>: Caches have finite capacity.</p><p><strong>Fix</strong></p><ul><li><p><strong>Hybrid HTM-STM</strong>Transactions start using the HTM mode. If hardware resources are exceeded, the transactions are rolled back and restarted in the STM mode.</p><blockquote><p><strong>Implementation Details</strong></p><p>To avoid the need for two versions of the code, the software mode of a hybrid STM system can be provided through the operating system with conflict detection at the granularity of memory pages.</p><p><strong>My Thoughts</strong></p><p>A cache line may be of 32-512 bytes. The granularity for STM should be larger than this number. A page is convenient to maintain.</p></blockquote></li><li><p><strong>HASTM (hardware-accelerated STM)</strong>: HTM targets main sources of overhead of STM. Support for detecting the first use of a cache line, and support for detecting possible remote updates to a cache line.</p></li></ul>`,31);function T(n,s,e,t,o,a){const r=y("center");return g(),m("div",null,[w,l(r,null,{default:i(()=>[k]),_:1}),l(r,null,{default:i(()=>[c("button",{class:u(n.$style.button),onClick:s[0]||(s[0]=(...d)=>a.open&&a.open(...d))},"Performance of Transactions vs. Locks",2)]),_:1}),v])}const _={$style:f},S=h(b,[["render",T],["__cssModules",_]]);export{C as __pageData,S as default};
